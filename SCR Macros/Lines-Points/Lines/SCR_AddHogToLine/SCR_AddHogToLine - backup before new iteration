import clr
import sys
import csv
import copy
import math
import os
import System

from timeit import default_timer as timer
from datetime import timedelta

clr.AddReference ('IronPython.Wpf')
import wpf

from System import Math, Action, Func, String
from System.Text import Encoding
from System.Collections.Generic import List, IEnumerable
from System.Windows import Visibility
from System.Windows.Controls import StackPanel, ComboBox, ComboBoxItem, ListBox, ListBoxItem, ItemCollection
from System.Windows.Input import Keyboard, AccessKeyManager
from System import Type, Tuple, Array, Double
from System.IO import StreamReader, MemoryStream, File
from System.Windows.Threading import Dispatcher
clr.AddReference ("System.Drawing")
from System.Drawing import Bitmap, Color
clr.AddReference ("System.Windows.Forms")
from System.Windows.Forms import Control, Keys, OpenFileDialog, DialogResult, FolderBrowserDialog, ColumnHeader 

# we are referencing way too many Trimble functions
# but that way it is easier to fix in case they move stuff around again
try:
    clr.AddReference ("Trimble.Sdk") # In version 5.50, model assemblies are "pre-referenced"
    clr.AddReference ("Trimble.Sdk.Primitives") # contains Trimble.Vce.Collections
    clr.AddReference ("Trimble.Sdk.GraphicsModel") # Trimble.Vce.TTMetrics

except:
    clr.AddReference ("Trimble.DiskIO")
    clr.AddReference ("Trimble.Vce.Alignment")
    clr.AddReference ("Trimble.Vce.Collections")
    clr.AddReference ("Trimble.Vce.Coordinates")
    clr.AddReference ("Trimble.Vce.Core")
    clr.AddReference ("Trimble.Vce.Data")
    clr.AddReference ("Trimble.Vce.Data.COGO")
    clr.AddReference ("Trimble.Vce.Data.Construction")
    clr.AddReference ("Trimble.Vce.Data.Scanning")
    clr.AddReference ("Trimble.Vce.Data.RawData")
    clr.AddReference ("Trimble.Vce.ForeignCad")
    clr.AddReference ("Trimble.Vce.Gem")
    clr.AddReference ("Trimble.Vce.Geometry")
    clr.AddReference ("Trimble.Vce.Interfaces")
    clr.AddReference ("Trimble.Vce.TTMetrics")
    clr.AddReference ("Trimble.Vce.Units")

from Trimble.DiskIO import OptionsManager

from Trimble.Vce.Alignment import ProfileView, VerticalAlignment, Linestring, AlignmentLabel, DrapedLine

from Trimble.Vce.Alignment.Linestring import Linestring,ElementFactory, IStraightSegment, IXYZLocation, IPointIdLocation

from Trimble.Vce.Collections import Point3DArray, DynArray

from Trimble.Vce.Coordinates import Point as CoordPoint, ICoordinate, PointCollection

from Trimble.Vce.Core import TransactMethodCall, ModelEvents

from Trimble.Vce.Core.Components import WorldView, Project, Layer, LayerGroupCollection, LayerCollection, TextStyle, TextStyleCollection, LineStyleCollection, BlockView, EntityContainerBase, PointLabelStyle, SnapInAttributeExtension

from Trimble.Vce.Data import PointCloudSelection, FileProperties, FilePropertiesContainer

from Trimble.Vce.Data.COGO import Calc

from Trimble.Vce.Data.Construction.IFC import IFCMesh

from Trimble.Vce.Data.Construction.Settings import ConstructionCommandsSettings

from Trimble.Vce.Data.RawData import PointManager, RawDataContainer

clr.AddReference ("Trimble.Vce.Data.RXL")
from Trimble.Vce.Data.RXL import RXLAlignmentExporter, FileWriter as RxlFileWriter, Versions as RxlVersions

from Trimble.Vce.Data.Scanning import PointCloudRegion, ExposedPointCloudRegion

from Trimble.Vce.ForeignCad import PolyLine, Poly3D, Arc as ArcObject, Circle as CadCircle # we are also using Arc from geometry
from Trimble.Vce.ForeignCad import Point as CadPoint, MText, Text as CadText, BlockReference, Leader, LeaderType, DimArrowheadType

from Trimble.Vce.Gem import VextexAndTriangleList, Model3D, ProjectedSurface, Gem, Filer, Model3DCompSettings

from Trimble.Vce.Geometry import Triangle2D, Triangle3D, Point3D, Plane3D, Arc, Matrix4D, Vector2D, Vector3D, PolySeg, Limits3D, Side, Intersections, RectangleD, Primitive, PrimitiveLocation, Conversions

from Trimble.Vce.Geometry.PolySeg.Segment import Segment, Line as SegmentLine, Arc as ArcSegment, Parabola as ParabolaSegment

from Trimble.Vce.Interfaces import Client, ProgressBar

from Trimble.Vce.Interfaces.Client import CommandGranularity

from Trimble.Vce.Interfaces.Core import OverrideByLayer

from Trimble.Vce.Interfaces.SnapIn import IPolyseg, IName, IHaveUcs, ISnapIn, IPointCloudReader, IMemberManagement, ICollectionOfEntities, TransformData

from Trimble.Vce.Interfaces.PointCloud import IExposedPointCloudRegion

from Trimble.Vce.SurveyCAD import ProjectLineStyle

from Trimble.Vce.TTMetrics import StrokeFont, StrokeFontManager

clr.AddReference ("Trimble.Vce.UI.BaseCommands")
from Trimble.Vce.UI.BaseCommands import ViewHelper, SelectionContextMenuHandler, ExploreObjectControlHelper

clr.AddReference ("Trimble.Vce.UI.Controls")
from Trimble.Vce.UI.Controls import SurfaceTypeLists, GlobalSelection, TrimbleColor, ExplorerUI, ExplorerItemCollection

clr.AddReference("Trimble.Vce.UI.UIManager")
from Trimble.Vce.UI.UIManager import UIEvents

# later version of TBC moved these to a different assembly. If not found in new location, look at old
try:
	#5.50
    from Trimble.Sdk.Interfaces.UI import InputMethod, MousePosition, CursorStyle, ControlBoolean, UIEventArgs, I2DProjection
except:
    try:
		#5.40 or so
        from Trimble.Vce.UI.UIManager import UIEventArgs
        from Trimble.CustomControl.Interfaces import MousePosition, ControlBoolean, I2DProjection
        from Trimble.CustomControl.Interfaces.Enums import CursorStyle, InputMethod
    except:
		# even older
        from Trimble.Vce.UI.Controls import MousePosition, CursorStyle, ControlBoolean, TrimbleColor

def Setup(cmdData, macroFileFolder):
    cmdData.Key = "SCR_AddHogToLine"
    cmdData.CommandName = "SCR_AddHogToLine"
    cmdData.Caption = "_SCR_AddHogToLine"
    cmdData.UIForm = "SCR_AddHogToLine"      # MUST MATCH NAME FROM CLASS DEFINED BELOW !!!
    cmdData.HelpFile = "Macros.chm"
    cmdData.HelpTopic = "22602"

    try:
        cmdData.DefaultTabKey = "SCR Reports/Lines/Points"
        cmdData.DefaultTabGroupKey = "Lines/Points"
        cmdData.ShortCaption = "Add Weight-Hog"
        cmdData.DefaultRibbonToolSize = 3 # Default=0, ImageOnly=1, Normal=2, Large=3

        cmdData.Version = 1.01
        cmdData.MacroAuthor = "SCR"
        cmdData.MacroInfo = r""
        
        cmdData.ToolTipTitle = "add Weight Hog to Stringlines"
        cmdData.ToolTipTextFormatted = "add Weight Hog to Stringlines"

    except:
        pass
    try:
        b = Bitmap (macroFileFolder + "\\" + cmdData.Key + ".png")
        cmdData.ImageSmall = b
    except:
        pass


class SCR_AddHogToLine(StackPanel): # this inherits from the WPF StackPanel control
    def __init__(self, currentProject, macroFileFolder):
        with StreamReader (macroFileFolder + r"\SCR_AddHogToLine.xaml") as s:
            wpf.LoadComponent (self, s)
        self.currentProject = currentProject


    def OnLoad(self, cmd, buttons, event):
        self.okBtn = buttons[0]
        self.Caption = cmd.Command.Caption

        self.hog.NumberOfDecimals = 4
        self.hortol.NumberOfDecimals = 4
        self.vertol.NumberOfDecimals = 4
        self.nodespacing.NumberOfDecimals = 4

        self.linepicker1.IsEntityValidCallback = self.IsValid
        self.lType = clr.GetClrType(IPolyseg)

        self.SetDefaultOptions()

    def SetDefaultOptions(self):

        self.hog.Value = OptionsManager.GetDouble("SCR_AddHogToLine.hog", 0.005)
        self.hortol.Value = OptionsManager.GetDouble("SCR_AddHogToLine.hortol", 0.0001)
        self.vertol.Value = OptionsManager.GetDouble("SCR_AddHogToLine.vertol", 0.0001)
        self.nodespacing.Value = OptionsManager.GetDouble("SCR_AddHogToLine.nodespacing", 2)

        lserial = OptionsManager.GetUint("SCR_AddHogToLine.layerpicker", 8)
        o = self.currentProject.Concordance.Lookup(lserial) # get the object withj the saved serial number
        if o != None:   # check if we actually got an object back
            if isinstance(o.GetSite(), LayerCollection):    # check if the object is a layer
                self.layerpicker.SetSelectedSerialNumber(lserial, InputMethod(3))
            else:  # if not then set Layer zero                       
                self.layerpicker.SetSelectedSerialNumber(8, InputMethod(3))
        else:   # if not then set Layer zero               
            self.layerpicker.SetSelectedSerialNumber(8, InputMethod(3))


        self.createisopachlinestring.IsChecked = OptionsManager.GetBool("SCR_AddHogToLine.createisopachlinestring", False)
        self.hogarc.IsChecked = OptionsManager.GetBool("SCR_AddHogToLine.hogarc", False)
        self.hogparabola.IsChecked = OptionsManager.GetBool("SCR_AddHogToLine.hogparabola", True)

    def SaveOptions(self):

        OptionsManager.SetValue("SCR_AddHogToLine.hog", self.hog.Value)
        OptionsManager.SetValue("SCR_AddHogToLine.hortol", self.hortol.Value)
        OptionsManager.SetValue("SCR_AddHogToLine.vertol", self.vertol.Value)
        OptionsManager.SetValue("SCR_AddHogToLine.nodespacing", self.nodespacing.Value)
        
        OptionsManager.SetValue("SCR_AddHogToLine.layerpicker", self.layerpicker.SelectedSerialNumber)

        OptionsManager.SetValue("SCR_AddHogToLine.createisopachlinestring", self.createisopachlinestring.IsChecked)    
        OptionsManager.SetValue("SCR_AddHogToLine.hogarc", self.hogarc.IsChecked)    
        OptionsManager.SetValue("SCR_AddHogToLine.hogparabola", self.hogparabola.IsChecked)    

    def IsValid(self, serial):
        o=self.currentProject.Concordance.Lookup(serial)
        if isinstance(o, self.lType):
            return True
        return False

    def CancelClicked(self, cmd, args):
        cmd.CloseUICommand ()


    def OkClicked(self, cmd, e):
        Keyboard.Focus(self.okBtn)
        self.error.Content=''
        self.success.Content = ''

        UIEvents.RaiseBeforeDataProcessing(self, UIEventArgs())
        self.currentProject.TransactionManager.AddBeginMark(CommandGranularity.Command, self.Caption)
        
        wv = self.currentProject [Project.FixedSerial.WorldView]
        lgc = LayerGroupCollection.GetLayerGroupCollection(self.currentProject, False)
                
        wv.PauseGraphicsCache(True)

        # self.label_benchmark.Content = ''

        # settings = Model3DCompSettings.ProvideSettingsObject(self.currentProject)

        try:

            with TransactMethodCall(self.currentProject.TransactionCollector) as failGuard:
                l1 = self.linepicker1.Entity
                if isinstance(l1, self.lType):
                    polyseg1 = l1.ComputePolySeg()
                    polyseg1 = polyseg1.ToWorld()
                    polyseg1_v = l1.ComputeVerticalPolySeg()
                    
                    t1 = abs(self.hortol.Value)
                    t2 = abs(self.vertol.Value)
                    t3 = abs(self.nodespacing.Value)

                    startstation = polyseg1.BeginStation
                    endstation = polyseg1.ComputeStationing()
                    
                    hog = self.hog.Value

                    if self.hogarc.IsChecked:
                        hogradius = (hog**2 + (endstation/2)**2)/(2*hog)
                        # create a vertical polyseg
                        hogpolyseg = PolySeg.PolySeg()
                        # and add the arc geometry
                        hogpolyseg.Add(ArcSegment(Point3D(startstation, 0), Point3D(endstation, 0), -1*hogradius))
                        
                        if hog > endstation/2:
                            self.error.Content += '\nArc Solution probably incorrect\nHog is greater than half the line length'
                            isopachname = "?? incorrect Arc ?? - " + IName.Name.__get__(l1) + " - Isopach-Arc with " + str(hog*1000) + " mm Hog"
                            linename = "?? incorrect Arc ?? - " + IName.Name.__get__(l1) + " - Arc with " + str(hog*1000) + " mm Hog"
                        else:
                            isopachname = IName.Name.__get__(l1) + " - Isopach-Arc with " + str(hog*1000) + " mm Hog"
                            linename = IName.Name.__get__(l1) + " - Arc with " + str(hog*1000) + " mm Hog"


                    else: # Parabola

                        # hog = a * endstation/2^2
                        a = hog / ((endstation/2)**2)
                        para_slope = 2 * a * (endstation/2)
                        para_el = para_slope * (endstation/2)
                        # create a vertical polyseg
                        hogpolyseg = PolySeg.PolySeg()
                        # and add the parabola geometry
                        hogpolyseg.Add(ParabolaSegment(Point3D(startstation, 0), Point3D(endstation/2, para_el), Point3D(endstation, 0)))

                        isopachname = IName.Name.__get__(l1) + " - Isopach-Parabola with " + str(hog*1000) + " mm Hog"
                        linename = IName.Name.__get__(l1) + " - Parabola with " + str(hog*1000) + " mm Hog"


                    if self.createisopachlinestring.IsChecked:
                        l_hog_iso = wv.Add(clr.GetClrType(Linestring))
                        l_hog_iso.Append(polyseg1, hogpolyseg, False, False)
                        l_hog_iso.Name = isopachname
                        l_hog_iso.Layer = self.layerpicker.SelectedSerialNumber

                    # chord the hog geometry                        
                    chordedhog = hogpolyseg.Linearize(t1, t2, t3, None, False)

                    # create the new line in the worldview and draw the segments
                    l_with_hog = wv.Add(clr.GetClrType(Linestring))
                    l_with_hog.Name = linename
                    l_with_hog.Layer = self.layerpicker.SelectedSerialNumber

                    nodes = chordedhog.ToPoint3DArray()
                    # go through the chord nodes
                    # get the original position and elevation, add the hog value and draw it
                    for node in nodes: # node list of linearized profile with X as chainage and Y as elevation
                        p1 = polyseg1.FindPointFromStation(node.X)[1]
                        if polyseg1_v != None:
                            p1.Z = polyseg1_v.ComputeVerticalSlopeAndGrade(node.X)[1]

                        p2 = Point3D(p1)
                        p2.Z += node.Y

                        e = ElementFactory.Create(clr.GetClrType(IStraightSegment), clr.GetClrType(IXYZLocation))
                        e.Position = p2  # we draw that string line segment
                        l_with_hog.AppendElement(e)

                failGuard.Commit()
                UIEvents.RaiseAfterDataProcessing(self, UIEventArgs())
                self.currentProject.TransactionManager.AddEndMark(CommandGranularity.Command)
        
        except Exception as e:
            tt = sys.exc_info()
            exc_type, exc_obj, exc_tb = sys.exc_info()
            # EndMark MUST be set no matter what
            # otherwise TBC won't work anymore and needs to be restarted
            self.currentProject.TransactionManager.AddEndMark(CommandGranularity.Command)
            UIEvents.RaiseAfterDataProcessing(self, UIEventArgs())
            self.error.Content += '\nan Error occurred - Result probably incomplete\n' + str(exc_type) + '\n' + str(exc_obj) + '\nLine ' + str(exc_tb.tb_lineno)

        
        self.success.Content += '\nDone'
        
        wv.PauseGraphicsCache(False)

        Keyboard.Focus(self.linepicker1)

        self.SaveOptions()

    

