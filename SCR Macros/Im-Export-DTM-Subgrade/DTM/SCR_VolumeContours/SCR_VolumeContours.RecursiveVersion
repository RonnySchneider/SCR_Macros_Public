import clr
import csv
import copy
import math
import os
import System
import shutil
import webbrowser

from timeit import default_timer as timer
from datetime import timedelta

clr.AddReference ('IronPython.Wpf')
import wpf

from System import Math, Action, Func, String, Byte, Int32
from System.Text import Encoding
from System.Collections.Generic import List, IEnumerable
from System.Windows import Visibility
from System.Windows.Controls import StackPanel, ComboBox, ComboBoxItem, ListBox, ListBoxItem, ItemCollection
from System.Windows.Input import Keyboard, AccessKeyManager
from System import Type, Tuple, Array, Double
from System.IO import StreamReader, MemoryStream, File
from System.Windows.Threading import Dispatcher
clr.AddReference ("System.Drawing")
from System.Drawing import Bitmap, Color
clr.AddReference ("System.Windows.Forms")
from System.Windows.Forms import Control, Keys, OpenFileDialog, DialogResult, FolderBrowserDialog, ColumnHeader 

# we are referencing way too many Trimble functions
# but that way it is easier to fix in case they move stuff around again
try:
    clr.AddReference ("Trimble.Sdk") # In version 5.50, model assemblies are "pre-referenced"
    clr.AddReference ("Trimble.Sdk.Primitives") # contains Trimble.Vce.Collections
    clr.AddReference ("Trimble.Sdk.GraphicsModel") # Trimble.Vce.TTMetrics
    clr.AddReference ("Trimble.Sdk.SurveyCad") # Trimble.Vce.SurveyCAD

except:
    clr.AddReference ("Trimble.DiskIO")
    clr.AddReference ("Trimble.Vce.Alignment")
    clr.AddReference ("Trimble.Vce.Collections")
    clr.AddReference ("Trimble.Vce.Coordinates")
    clr.AddReference ("Trimble.Vce.Core")
    clr.AddReference ("Trimble.Vce.Data")
    clr.AddReference ("Trimble.Vce.Data.COGO")
    clr.AddReference ("Trimble.Vce.Data.Construction")
    clr.AddReference ("Trimble.Vce.Data.Scanning")
    clr.AddReference ("Trimble.Vce.Data.RawData")
    clr.AddReference ("Trimble.Vce.ForeignCad")
    clr.AddReference ("Trimble.Vce.Gem")
    clr.AddReference ("Trimble.Vce.Geometry")
    clr.AddReference ("Trimble.Vce.Interfaces")
    clr.AddReference ("Trimble.Vce.TTMetrics")
    clr.AddReference ("Trimble.Vce.Units")

from Trimble.DiskIO import OptionsManager

from Trimble.Vce.Alignment import ProfileView, VerticalAlignment, Linestring, AlignmentLabel, DrapedLine, DynaView

from Trimble.Vce.Alignment.Linestring import Linestring,ElementFactory, IStraightSegment, IXYZLocation, IPointIdLocation

from Trimble.Vce.Collections import Point3DArray, DynArray

from Trimble.Vce.Coordinates import Point as CoordPoint, ICoordinate, PointCollection, OfficeEnteredCoord, KeyedIn, CoordComponentType, CoordQuality, CoordSystem

from Trimble.Vce.Core import TransactMethodCall, ModelEvents

from Trimble.Vce.Core.Components import WorldView, Project, Layer, LayerGroupCollection, LayerCollection, TextStyle, TextStyleCollection, LineStyleCollection, BlockView, EntityContainerBase, PointLabelStyle

from Trimble.Vce.Data import PointCloudSelection, FileProperties, FilePropertiesContainer, MediaFolder, MediaFolderContainer

from Trimble.Vce.Data.COGO import Calc

from Trimble.Vce.Data.Construction.IFC import IFCMesh

from Trimble.Vce.Data.Construction.Settings import ConstructionCommandsSettings

from Trimble.Vce.Data.RawData import PointManager, RawDataContainer

clr.AddReference ("Trimble.Vce.Data.RXL")
from Trimble.Vce.Data.RXL import RXLAlignmentExporter, FileWriter as RxlFileWriter, Versions as RxlVersions

from Trimble.Vce.Data.Scanning import PointCloudRegion, ExposedPointCloudRegion

from Trimble.Vce.ForeignCad import PolyLine, Poly3D, Arc as ArcObject, Circle as CadCircle, Face3D, AttachmentPoint # we are also using Arc from geometry
from Trimble.Vce.ForeignCad import Point as CadPoint, MText, Text as CadText, BlockReference, Leader, LeaderType, DimArrowheadType, PointLabelEntity as CadLabel

from Trimble.Vce.Gem import VextexAndTriangleList, Model3D, ProjectedSurface, Gem, Filer, DtmVolumes, Model3DQuickContours, Model3DContoursBuilder

from Trimble.Vce.Geometry import Triangle2D, Triangle3D, Point3D, Plane3D, Arc, Matrix4D, Vector2D, Vector3D, BiVector3D, Spinor3D, PolySeg, Limits3D, Side, Intersections, RectangleD, Primitive, PrimitiveLocation, Conversions

from Trimble.Vce.Geometry.PolySeg.Segment import Segment, Line as SegmentLine, Arc as ArcSegment

from Trimble.Vce.Interfaces import Client, ProgressBar, Units as IUnits

from Trimble.Vce.Interfaces.Client import CommandGranularity

from Trimble.Vce.Interfaces.Core import OverrideByLayer

from Trimble.Vce.Interfaces.SnapIn import IPolyseg, IName, IHaveUcs, ISnapIn, IPointCloudReader, IMemberManagement, ICollectionOfEntities, TransformData

from Trimble.Vce.Interfaces.PointCloud import IExposedPointCloudRegion

from Trimble.Vce.Interfaces.Units import LinearType

from Trimble.Vce.PlanSet import PlanSetSheetViews, PlanSetSheetView, SheetSet, BasicSheet

from Trimble.Vce.SurveyCAD import ProjectLineStyle, TextDisplayAttr

from Trimble.Vce.TTMetrics import StrokeFont, StrokeFontManager

clr.AddReference ("Trimble.Vce.UI.BaseCommands")
from Trimble.Vce.UI.BaseCommands import ViewHelper, SelectionContextMenuHandler, ExploreObjectControlHelper

clr.AddReference ("Trimble.Vce.UI.Controls")
from Trimble.Vce.UI.Controls import SurfaceTypeLists, GlobalSelection, TrimbleColor, ExplorerUI, ExplorerItemCollection

clr.AddReference("Trimble.Vce.UI.Hoops")
from Trimble.Vce.UI.Hoops import Hoops2dView

clr.AddReference("Trimble.Vce.UI.UIManager")
from Trimble.Vce.UI.UIManager import UIEvents, TrimbleOffice

# later version of TBC moved these to a different assembly. If not found in new location, look at old
try:
	#5.50
    from Trimble.Sdk.Interfaces.UI import InputMethod, MousePosition, CursorStyle, ControlBoolean, UIEventArgs, I2DProjection
except:
    try:
		#5.40 or so
        from Trimble.Vce.UI.UIManager import UIEventArgs
        from Trimble.CustomControl.Interfaces import MousePosition, ControlBoolean, I2DProjection
        from Trimble.CustomControl.Interfaces.Enums import CursorStyle, InputMethod
    except:
		# even older
        from Trimble.Vce.UI.Controls import MousePosition, CursorStyle, ControlBoolean, TrimbleColor


def Setup(cmdData, macroFileFolder):
    cmdData.Key = "SCR_BasinFindVolumeRL"
    cmdData.CommandName = "SCR_BasinFindVolumeRL"
    cmdData.Caption = "_SCR_BasinFindVolumeRL"
    cmdData.UIForm = "SCR_BasinFindVolumeRL"      # MUST MATCH NAME FROM CLASS DEFINED BELOW !!!
    cmdData.HelpFile = "Macros.chm"
    cmdData.HelpTopic = "22602"

    try:
        cmdData.DefaultTabKey = "SCR ImExport/DTM/Subgrade"
        cmdData.DefaultTabGroupKey = "DTM"
        cmdData.ShortCaption = "Basin Target RL"
        cmdData.DefaultRibbonToolSize = 3 # Default=0, ImageOnly=1, Normal=2, Large=3

        cmdData.Version = 1.02
        cmdData.MacroAuthor = "SCR"
        cmdData.MacroInfo = r""
        
        cmdData.ToolTipTitle = "Basin Target RL"
        cmdData.ToolTipTextFormatted = "Computes the RL at which a Surface contains a chosen Volume"

    except:
        pass
    try:
        b = Bitmap (macroFileFolder + "\\" + cmdData.Key + ".png") # we have to include a icon revision, otherwise TBC might not show the new one
        cmdData.ImageSmall = b
    except:
        pass


class SCR_BasinFindVolumeRL(StackPanel): # this inherits from the WPF StackPanel control
    def __init__(self, currentProject, macroFileFolder):
        with StreamReader (macroFileFolder + r"\SCR_BasinFindVolumeRL.xaml") as s:
            wpf.LoadComponent (self, s)
        self.currentProject = currentProject


    def OnLoad(self, cmd, buttons, event):
        self.Caption = cmd.Command.Caption

        types = Array [Type] (SurfaceTypeLists.AllWithCutFillMap)    # we fill an array with TBC object types, we could combine different types
        self.surfacepicker.FilterByEntityTypes = types    # we fill the dropdownlist by applying that types array as filter
        self.surfacepicker.AllowNone = False              # our list shall not show an empty field

        # get the units for linear distance
        self.lunits = self.currentProject.Units.Linear
        self.lfp = self.lunits.Properties.Copy()
        linearsuffix = self.lunits.Units[self.lunits.DisplayType].Abbreviation
        #self.lfp.AddSuffix = False
        self.sliceintervallabel.Content = "Slice Interval [" + self.lunits.Units[self.lunits.DisplayType].Abbreviation + "]"

        # get the units for volumes
        self.vunits = self.currentProject.Units.Volume
        self.vfp = self.vunits.Properties.Copy()
        #self.vfp.AddSuffix = False
        self.targetvolumelabel.Content = "Target Volume [" + self.vunits.Units[self.vunits.DisplayType].Abbreviation + "]"
        
        self.targetvolume.MinValue = 0
        self.targetvolume.NumberOfDecimals = self.vunits.Units[self.vunits.DisplayType].NumberOfDecimals
        self.sliceinterval.MinValue = 0.0001 # otherwise the volume computation fails
        self.sliceinterval.NumberOfDecimals = self.lunits.Units[self.lunits.DisplayType].NumberOfDecimals

        self.SetDefaultOptions()

    def SetDefaultOptions(self):
        try:    self.surfacepicker.SelectIndex(OptionsManager.GetInt("SCR_BasinFindVolumeRL.surfacepicker", 0))
        except: self.surfacepicker.SelectIndex(0)
        self.targetvolume.Value = OptionsManager.GetDouble("SCR_BasinFindVolumeRL.targetvolume", 1.00)
        self.sliceinterval.Value = OptionsManager.GetDouble("SCR_BasinFindVolumeRL.sliceinterval", 0.0001)
        self.createcontour.IsChecked = OptionsManager.GetBool("SCR_BasinFindVolumeRL.createcontour", True)

    def SaveOptions(self):
        OptionsManager.SetValue("SCR_BasinFindVolumeRL.surfacepicker", self.surfacepicker.SelectedIndex)
        OptionsManager.SetValue("SCR_BasinFindVolumeRL.targetvolume", self.targetvolume.Value)
        OptionsManager.SetValue("SCR_BasinFindVolumeRL.sliceinterval", self.sliceinterval.Value)
        OptionsManager.SetValue("SCR_BasinFindVolumeRL.createcontour", self.createcontour.IsChecked)

    def OkClicked(self, cmd, e):

        #self.currentProject.TransactionManager.AddBeginMark(CommandGranularity.Command, self.Caption)
        #UIEvents.RaiseBeforeDataProcessing(self, UIEventArgs())

        wv = self.currentProject [Project.FixedSerial.WorldView]

        # the "with" statement will unroll any changes if something go wrong
        #with TransactMethodCall(self.currentProject.TransactionCollector) as failGuard:

        # TBC internally computes in meter
        sliceintervalmeter = self.lunits.Convert(self.lunits.DisplayType, self.sliceinterval.Value, self.lunits.InternalType)
        targetvolumemeter = self.vunits.Convert(self.vunits.DisplayType, self.targetvolume.Value, self.vunits.InternalType)
        
        # get the surface as object
        surface = wv.Lookup(self.surfacepicker.SelectedSerial)
        
        if (surface.MaxElevation - math.floor(surface.MinElevation)) > 100.0:
            increment = 100
        elif (surface.MaxElevation - math.floor(surface.MinElevation)) > 10.0:
            increment = 10
        elif (surface.MaxElevation - math.floor(surface.MinElevation)) > 1.0:
            increment = 1
        elif (surface.MaxElevation - math.floor(surface.MinElevation)) > 0.1:
            increment = 0.1
        elif (surface.MaxElevation - math.floor(surface.MinElevation)) > 0.01:
            increment = 0.01
        elif (surface.MaxElevation - math.floor(surface.MinElevation)) > 0.001:
            increment = 0.001
        elif (surface.MaxElevation - math.floor(surface.MinElevation)) > 0.0001:
            increment = 0.0001

        result = self.findelevation(surface, increment, math.floor(surface.MinElevation), targetvolumemeter) #surface, increment, compelevation, targetvolume
            
                ## sum up the slices until we hit our target
                #summeter = 0
                #solutionfound = False
                #for i in range(1, volumesCut.Count):
                #    summeter += volumesCut[i]
                #    if summeter >= targetvolumemeter:
                #        solutionfound = True
                #        solutionmeter = levels[i]
                #        break
    
        # check if we found a solution
        if result[0] == True:
            # create the result strings - back in project dimensions
            solutionelevation = self.lunits.Format(result[1], self.lfp)
            solutionvolume = self.vunits.Format(result[2], self.vfp)
            self.success.Content += "\nRL " + solutionelevation + " -> " + solutionvolume
        
            if self.createcontour.IsChecked: 
                if result[1] <= surface.MaxElevation:
                    # create a contour if asked for
                    cb = Model3DContoursBuilder()
                    cb.SetSurface(surface)
                    cb.SetName("RL " + solutionelevation + " -> " + solutionvolume)
                    cb.SetContourType(Model3DQuickContours.SurfaceContourType.eSingleElevation)
                    cb.SetSingleElevation(result[1])
                    cb.SetSingleContourColor(Color.Red)
                    cb.Commit()
                else:
                    self.success.Content += "\nSolution is above Surface - no Contour created\n"
        
        
        else:
            self.success.Content += "\nNo Solution found"
        #failGuard.Commit()


        #self.currentProject.TransactionManager.AddEndMark(CommandGranularity.Command)
        #UIEvents.RaiseAfterDataProcessing(self, UIEventArgs())
        ProgressBar.TBC_ProgressBar.Title = ""
        self.SaveOptions()  

    def findelevation(self, surface, increment, compelevation, targetvolumemeter):
    
        # set the computation settings
        comp_settings = DtmVolumes.Settings()
        comp_settings.method = DtmVolumes.Method.DatumToDtm
        comp_settings.summary = DtmVolumes.Summary.ByTotal
        comp_settings.zDatum = compelevation
        #comp_settings.zIncrement = sliceintervalmeter
        #comp_settings.zIndex = math.floor(surface.MinElevation)

        # prepare the output variables
        out_comp_results = clr.StrongBox[DtmVolumes.Results]()
        out_isopach = clr.StrongBox[Gem]()
            
        no_gem = clr.StrongBox[Gem](None)
        
        # create the isopach, since we compute DatumToDtm we have to pass it the no_gem Strongbox, it won't accept None
        if DtmVolumes.ComputeVolumeIsopach(comp_settings, no_gem, surface.Gem, out_isopach):
            # compute the volumeslices - here it must be the Strongbox.Value, it won't accept None
            if DtmVolumes.ComputeVolumeResults(comp_settings, no_gem.Value, out_isopach.Value, out_comp_results):
    
                volume = out_comp_results.Value.volumesCut[0]
                
                ProgressBar.TBC_ProgressBar.Title = "Increment " + str(increment) + " / Vol-Diff " + str(round(targetvolumemeter - volume, 1)) + " "
                if ProgressBar.TBC_ProgressBar.SetProgress(0):
                    return [False, 0, 0]  # function returns true if user pressed cancel

                if abs(increment) < 0.00001: #abs(targetvolumemeter - volume) < 0.00001:
                    return [True, compelevation, volume]
                else:
                    if (targetvolumemeter - volume) > 0: # we are still below the target
                        # we are incrementing upwards only, keep going
                        return self.findelevation(surface, increment, compelevation + increment, targetvolumemeter)
                    else:   # in case we are already above the target it was the last step
                        # reduce the elevation by the last increment
                        compelevation -= increment
                        # compute a new new increment
                        increment = increment / 2.0
                        return self.findelevation(surface, increment, compelevation + increment, targetvolumemeter)
            else:
                return [False, 0, 0]
        else:
            return [False, 0, 0]